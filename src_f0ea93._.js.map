{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 5, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/src/app/api/utils/jwt-token-verify.ts"],"sourcesContent":["import { verify } from \"jsonwebtoken\";\r\nexport const jwtTokenVerify = (request: any) => {\r\n    try {\r\n        // if (request.cookies.get(process.env.TOKEN_NAME)) {\r\n        //     const tokenValue = request.cookies.get(process.env.TOKEN_NAME).value;\r\n        // } return undefined;\r\n        const tokenValue = request.headers.get(\"auth-token\")\r\n        let data = verify(tokenValue, process.env.JWT_KEY!);\r\n        return data;\r\n    } catch (error) {\r\n        return undefined;\r\n    }\r\n}"],"names":[],"mappings":";;;;;;AACO,MAAM,iBAAiB,CAAC;IAC3B,IAAI;QACA,qDAAqD;QACrD,4EAA4E;QAC5E,sBAAsB;QACtB,MAAM,aAAa,QAAQ,OAAO,CAAC,GAAG,CAAC;QACvC,IAAI,OAAO,CAAA,GAAA,uIAAA,CAAA,SAAM,AAAD,EAAE,YAAY,QAAQ,GAAG,CAAC,OAAO;QACjD,OAAO;IACX,EAAE,OAAO,OAAO;QACZ,OAAO;IACX;AACJ"}},
    {"offset": {"line": 23, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 28, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/src/app/api/utils/mysql.ts"],"sourcesContent":["import mysql from \"mysql2/promise\";\r\n\r\n/*\r\n- How to create connection using MySQL?\r\nexport async function createConnection(dbName: string) {\r\n    return await mysql.createConnection({\r\n        host: \"localhost\",\r\n        user: \"root\",\r\n        database: dbName,\r\n    });\r\n}\r\n*/\r\n\r\nexport const pool = mysql.createPool({\r\n    host: \"localhost\",\r\n    user: \"root\",\r\n    password: \"\",\r\n    database: \"accounts\",\r\n    waitForConnections: true,\r\n    connectionLimit: 10,\r\n    maxIdle: 10,\r\n    idleTimeout: 60000,\r\n    queueLimit: 0,\r\n    enableKeepAlive: true,\r\n    keepAliveInitialDelay: 0,\r\n})\r\n\r\n\r\nexport async function execute(query: string, params?: any[]) {\r\n    let connection;\r\n    try {\r\n        connection = await pool.getConnection();\r\n        let result: any, tableSchema: any;\r\n        if (params) [result, tableSchema] = await connection.execute(query, params)\r\n        else[result, tableSchema] = await connection.execute(query)\r\n        return result;\r\n    } catch (error) {\r\n        if (connection) connection.release();\r\n        console.log(\"Query:\", query);\r\n        console.error(\"Error:\", error);\r\n    } finally {\r\n        if (connection) connection.release();\r\n    }\r\n}"],"names":[],"mappings":";;;;;;;AAaO,MAAM,OAAO,mIAAA,CAAA,UAAK,CAAC,UAAU,CAAC;IACjC,MAAM;IACN,MAAM;IACN,UAAU;IACV,UAAU;IACV,oBAAoB;IACpB,iBAAiB;IACjB,SAAS;IACT,aAAa;IACb,YAAY;IACZ,iBAAiB;IACjB,uBAAuB;AAC3B;AAGO,eAAe,QAAQ,KAAa,EAAE,MAAc;IACvD,IAAI;IACJ,IAAI;QACA,aAAa,MAAM,KAAK,aAAa;QACrC,IAAI,QAAa;QACjB,IAAI,QAAQ,CAAC,QAAQ,YAAY,GAAG,MAAM,WAAW,OAAO,CAAC,OAAO;aAChE,CAAC,QAAQ,YAAY,GAAG,MAAM,WAAW,OAAO,CAAC;QACrD,OAAO;IACX,EAAE,OAAO,OAAO;QACZ,IAAI,YAAY,WAAW,OAAO;QAClC,QAAQ,GAAG,CAAC,UAAU;QACtB,QAAQ,KAAK,CAAC,UAAU;IAC5B,SAAU;QACN,IAAI,YAAY,WAAW,OAAO;IACtC;AACJ"}},
    {"offset": {"line": 64, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 69, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/src/utils/text-encode-decode.ts"],"sourcesContent":["export function encode(originalData: any) {\r\n    const shuffle: { [key: string]: string } = {\r\n        \"0\": \"1\", \"1\": \"3\", \"2\": \"5\", \"3\": \"7\", \"4\": \"9\",\r\n        \"5\": \"a\", \"6\": \"c\", \"7\": \"f\", \"8\": \"e\", \"9\": \"d\",\r\n        \"a\": \"b\", \"b\": \"8\", \"c\": \"6\", \"d\": \"4\", \"e\": \"2\", \"f\": \"0\"\r\n    };\r\n\r\n    const packet = JSON.stringify([originalData]);\r\n    const encoder = new TextEncoder();\r\n    const byteArray = encoder.encode(packet);\r\n    let hex = Array.from(byteArray).map(byte => byte.toString(16).padStart(2, '0')).join('');\r\n\r\n    let shuffledHex = \"\";\r\n    for (let i = 0; i < hex.length; i++) {\r\n        shuffledHex += shuffle[hex[i]];\r\n    }\r\n    return shuffledHex;\r\n}\r\n\r\nexport function decode(hexadecimalData: any) {\r\n    try {\r\n        const shuffle: { [key: string]: string } = {\r\n            \"1\": \"0\", \"3\": \"1\", \"5\": \"2\", \"7\": \"3\", \"9\": \"4\",\r\n            \"a\": \"5\", \"c\": \"6\", \"f\": \"7\", \"e\": \"8\", \"d\": \"9\",\r\n            \"b\": \"a\", \"8\": \"b\", \"6\": \"c\", \"4\": \"d\", \"2\": \"e\", \"0\": \"f\"\r\n        };\r\n\r\n        let hex = \"\";\r\n        for (let i = 0; i < hexadecimalData.length; i++) {\r\n            hex += shuffle[hexadecimalData[i]];\r\n        }\r\n\r\n        let byteArray = new Uint8Array(hex.match(/.{1,2}/g)!.map(byte => parseInt(byte, 16)));\r\n        const decoder = new TextDecoder();\r\n        const packet = decoder.decode(byteArray);\r\n        const originalData = JSON.parse(packet)[0];\r\n\r\n        return originalData;\r\n    } catch (error) {\r\n        console.log(\"Decode failed\", error);\r\n        return null;\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;AAAO,SAAS,OAAO,YAAiB;IACpC,MAAM,UAAqC;QACvC,KAAK;QAAK,KAAK;QAAK,KAAK;QAAK,KAAK;QAAK,KAAK;QAC7C,KAAK;QAAK,KAAK;QAAK,KAAK;QAAK,KAAK;QAAK,KAAK;QAC7C,KAAK;QAAK,KAAK;QAAK,KAAK;QAAK,KAAK;QAAK,KAAK;QAAK,KAAK;IAC3D;IAEA,MAAM,SAAS,KAAK,SAAS,CAAC;QAAC;KAAa;IAC5C,MAAM,UAAU,IAAI;IACpB,MAAM,YAAY,QAAQ,MAAM,CAAC;IACjC,IAAI,MAAM,MAAM,IAAI,CAAC,WAAW,GAAG,CAAC,CAAA,OAAQ,KAAK,QAAQ,CAAC,IAAI,QAAQ,CAAC,GAAG,MAAM,IAAI,CAAC;IAErF,IAAI,cAAc;IAClB,IAAK,IAAI,IAAI,GAAG,IAAI,IAAI,MAAM,EAAE,IAAK;QACjC,eAAe,OAAO,CAAC,GAAG,CAAC,EAAE,CAAC;IAClC;IACA,OAAO;AACX;AAEO,SAAS,OAAO,eAAoB;IACvC,IAAI;QACA,MAAM,UAAqC;YACvC,KAAK;YAAK,KAAK;YAAK,KAAK;YAAK,KAAK;YAAK,KAAK;YAC7C,KAAK;YAAK,KAAK;YAAK,KAAK;YAAK,KAAK;YAAK,KAAK;YAC7C,KAAK;YAAK,KAAK;YAAK,KAAK;YAAK,KAAK;YAAK,KAAK;YAAK,KAAK;QAC3D;QAEA,IAAI,MAAM;QACV,IAAK,IAAI,IAAI,GAAG,IAAI,gBAAgB,MAAM,EAAE,IAAK;YAC7C,OAAO,OAAO,CAAC,eAAe,CAAC,EAAE,CAAC;QACtC;QAEA,IAAI,YAAY,IAAI,WAAW,IAAI,KAAK,CAAC,WAAY,GAAG,CAAC,CAAA,OAAQ,SAAS,MAAM;QAChF,MAAM,UAAU,IAAI;QACpB,MAAM,SAAS,QAAQ,MAAM,CAAC;QAC9B,MAAM,eAAe,KAAK,KAAK,CAAC,OAAO,CAAC,EAAE;QAE1C,OAAO;IACX,EAAE,OAAO,OAAO;QACZ,QAAQ,GAAG,CAAC,iBAAiB;QAC7B,OAAO;IACX;AACJ"}},
    {"offset": {"line": 138, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 143, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/src/app/api/utils/request-response.ts"],"sourcesContent":["import { decode, encode } from \"@/utils/text-encode-decode\";\r\nimport { NextResponse } from \"next/server\";\r\n\r\n/*****\r\n * Modified version of receive requested payload\r\n * Prevent showing actual response on client browser\r\n * Able to received text, object, array, number, boolean etc. in encoded format\r\n ******/\r\nexport async function requestJson(request: any) {\r\n    const data = await request.json();\r\n    return decode(data.payload)\r\n}\r\n/*****\r\n * Modified version of NextResponse.json()\r\n * Prevent showing actual response on client browser\r\n * Able to return text, object, array, number, boolean etc. in encoded format\r\n ******/\r\nconst doEncode = true;\r\nexport function nextResponseJson(data: any, status?: number) {\r\n    if (doEncode) return NextResponse.json(data ? encode(data) : null, { status: status ? status : 200 })\r\n    else return NextResponse.json(data ? data : null, { status: status ? status : 200 })\r\n}"],"names":[],"mappings":";;;;;;;;;AAQO,eAAe,YAAY,OAAY;IAC1C,MAAM,OAAO,MAAM,QAAQ,IAAI;IAC/B,OAAO,CAAA,GAAA,0IAAA,CAAA,SAAM,AAAD,EAAE,KAAK,OAAO;AAC9B;AACA;;;;MAIM,GACN,MAAM,WAAW;AACV,SAAS,iBAAiB,IAAS,EAAE,MAAe;IACvD,wCAAc,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC,OAAO,CAAA,GAAA,0IAAA,CAAA,SAAM,AAAD,EAAE,QAAQ,MAAM;QAAE,QAAQ,SAAS,SAAS;IAAI;;;;AAEvG"}},
    {"offset": {"line": 169, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 174, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/src/app/api/utils/search-params.ts"],"sourcesContent":["export default function searchParams(request: any, key: string) {\r\n    const url = new URL(request.url);\r\n    const searchParams = new URLSearchParams(url.searchParams)\r\n    const searchKey = searchParams.get(key);\r\n    return searchKey || undefined;\r\n}"],"names":[],"mappings":";;;AAAe,SAAS,aAAa,OAAY,EAAE,GAAW;IAC1D,MAAM,MAAM,IAAI,IAAI,QAAQ,GAAG;IAC/B,MAAM,eAAe,IAAI,gBAAgB,IAAI,YAAY;IACzD,MAAM,YAAY,aAAa,GAAG,CAAC;IACnC,OAAO,aAAa;AACxB"}},
    {"offset": {"line": 183, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 188, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/src/utils/more.ts"],"sourcesContent":["/*****\r\n * Get URL pathnames in array\r\n * Example:\r\n    - URL: http://localhost:3000/home, Output: [\"home\"]\r\n    - URL: http://localhost:3000/home/electronics, Output: [\"home\", \"electronics\"]\r\n ******/\r\nexport function getUrlParams() {\r\n    const pathname = window.location.pathname;\r\n    const arr = pathname.slice(1).split(\"/\");\r\n    return arr\r\n}\r\n\r\n// -----\r\n// Check- Is a variable null or not?\r\n// Number, string, object, array data type can be validate here\r\n// -----\r\nexport function isNull(variable: any): boolean {\r\n    if (variable === \"\" || variable === null || variable === undefined) return true;\r\n\r\n    if (typeof variable === \"number\") {\r\n        if (variable === 0) return true;\r\n        else return false;\r\n    }\r\n    else if (typeof variable === \"string\") {\r\n        if (variable.trim() === \"\" || variable.trim() === null || variable.trim() === undefined) return true;\r\n        else return false;\r\n    } if (Array.isArray(variable)) {\r\n        if (variable.length === 0) return true;\r\n        else return false;\r\n    } else if (typeof variable === \"object\") {\r\n        if (Array.isArray(variable)) {\r\n            if (variable.length === 0) return true;\r\n            else return false;\r\n        } else {\r\n            if (Object.keys(variable).length === 0) return true;\r\n            else return false;\r\n        }\r\n    } else return true;\r\n}\r\n\r\n// -----\r\n// Check- Is a variable null or not?\r\n// Number, string, object, array data type can be validate here\r\n// -----\r\nexport function notNull(variable: any): boolean {\r\n    return isNull(variable) === true ? false : true;\r\n}\r\n\r\n// -----\r\n// Check- Is a letter or word or digit presented on a text/paragraph?\r\n// -----\r\nexport function searchKeywordMatched(text: string, keyword: string) {\r\n    try {\r\n        return text.toLowerCase().search(keyword.toLowerCase()) !== -1;\r\n    } catch (error: any) {\r\n        return text.search(keyword) !== -1;\r\n    }\r\n}\r\n\r\n// -----\r\n// It can pause the execution of an async function for defined time.\r\n// -----\r\nexport async function sleep(milliseconds: number) {\r\n    return new Promise(resolve => setTimeout(resolve, milliseconds));\r\n}\r\n\r\n// -----\r\n// It can generate an unique integer ID\r\n// -----\r\nlet previouslyCreatedId = 0;\r\nexport function createId(): number {\r\n    const newCreatedId = new Date().getTime() - 1709297743920; // Substracted time is 6:55PM, 1 March 2024\r\n    if (previouslyCreatedId < newCreatedId) {\r\n        previouslyCreatedId = newCreatedId;\r\n        return newCreatedId;\r\n    } else {\r\n        previouslyCreatedId++;\r\n        return previouslyCreatedId;\r\n    }\r\n}\r\n\r\n// -----\r\n// It can generate an unique string ID\r\n// -----\r\nexport function uniqueStringId(): string {\r\n    const timestamp = createId().toString();\r\n    let id = \"\";\r\n    for (let i = 0; i < timestamp.length; i++) {\r\n        id += timestamp[i];\r\n        if ((i + 1) % 3 === 0 && i !== timestamp.length - 1) {\r\n            const randomChar = String.fromCharCode(97 + Math.floor(Math.random() * 10)); // Random lowercase letter between 'a' and 'f'\r\n            id += randomChar;\r\n        }\r\n    }\r\n    return id;\r\n}\r\n\r\n// -----\r\n// Check- Is the device is mobile or not?\r\n// It only runs on client side\r\n// -----\r\nexport function isMobileDevice(): boolean {\r\n    return (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent));\r\n}\r\n\r\n// -----\r\n// Check- Is the device is mobile or not?\r\n// It only runs on client side\r\n// -----\r\n/*\r\nexport function cleanImageResizeOptions(imageElement: string) {\r\n    if (isNull(imageElement)) return imageElement;\r\n    else return imageElement.replaceAll(\r\n        `onmousedown=\"startImageResize(event)\" onmouseout=\"imageCornerSquareCtrl(false)\" onmousemove=\"setCursorOnImage(event)\"`,\r\n        \"\"\r\n    )\r\n        .replaceAll(`CLOUD_UPLOAD_DIR`, gv.cloudUploadDir)\r\n        .replaceAll(`hover:outline hover:outline-2 HoverOutlineDeep`, \"\")\r\n        .replaceAll(`nwse-resize`, \"default\")\r\n        .replaceAll(`nesw-resize`, \"default\")\r\n        .replaceAll(`EditorImage `, \"\");\r\n}\r\n*/\r\n\r\n/*****\r\n * Camel-case to sentence\r\n * Input: viewOthersHistory, Output: View others history\r\n ******/\r\nexport function camelCaseToSentence(input: string) {\r\n    // Add a space before each uppercase letter\r\n    let result = input.replace(/([A-Z])/g, ' $1');\r\n\r\n    // Capitalize the first character and make the rest lowercase\r\n    return result.charAt(0).toUpperCase() + result.slice(1).toLowerCase();\r\n}"],"names":[],"mappings":"AAAA;;;;;MAKM;;;;;;;;;;;AACC,SAAS;IACZ,MAAM,WAAW,OAAO,QAAQ,CAAC,QAAQ;IACzC,MAAM,MAAM,SAAS,KAAK,CAAC,GAAG,KAAK,CAAC;IACpC,OAAO;AACX;AAMO,SAAS,OAAO,QAAa;IAChC,IAAI,aAAa,MAAM,aAAa,QAAQ,aAAa,WAAW,OAAO;IAE3E,IAAI,OAAO,aAAa,UAAU;QAC9B,IAAI,aAAa,GAAG,OAAO;aACtB,OAAO;IAChB,OACK,IAAI,OAAO,aAAa,UAAU;QACnC,IAAI,SAAS,IAAI,OAAO,MAAM,SAAS,IAAI,OAAO,QAAQ,SAAS,IAAI,OAAO,WAAW,OAAO;aAC3F,OAAO;IAChB;IAAE,IAAI,MAAM,OAAO,CAAC,WAAW;QAC3B,IAAI,SAAS,MAAM,KAAK,GAAG,OAAO;aAC7B,OAAO;IAChB,OAAO,IAAI,OAAO,aAAa,UAAU;QACrC,IAAI,MAAM,OAAO,CAAC,WAAW;YACzB,IAAI,SAAS,MAAM,KAAK,GAAG,OAAO;iBAC7B,OAAO;QAChB,OAAO;YACH,IAAI,OAAO,IAAI,CAAC,UAAU,MAAM,KAAK,GAAG,OAAO;iBAC1C,OAAO;QAChB;IACJ,OAAO,OAAO;AAClB;AAMO,SAAS,QAAQ,QAAa;IACjC,OAAO,OAAO,cAAc,OAAO,QAAQ;AAC/C;AAKO,SAAS,qBAAqB,IAAY,EAAE,OAAe;IAC9D,IAAI;QACA,OAAO,KAAK,WAAW,GAAG,MAAM,CAAC,QAAQ,WAAW,QAAQ,CAAC;IACjE,EAAE,OAAO,OAAY;QACjB,OAAO,KAAK,MAAM,CAAC,aAAa,CAAC;IACrC;AACJ;AAKO,eAAe,MAAM,YAAoB;IAC5C,OAAO,IAAI,QAAQ,CAAA,UAAW,WAAW,SAAS;AACtD;AAEA,QAAQ;AACR,uCAAuC;AACvC,QAAQ;AACR,IAAI,sBAAsB;AACnB,SAAS;IACZ,MAAM,eAAe,IAAI,OAAO,OAAO,KAAK,eAAe,2CAA2C;IACtG,IAAI,sBAAsB,cAAc;QACpC,sBAAsB;QACtB,OAAO;IACX,OAAO;QACH;QACA,OAAO;IACX;AACJ;AAKO,SAAS;IACZ,MAAM,YAAY,WAAW,QAAQ;IACrC,IAAI,KAAK;IACT,IAAK,IAAI,IAAI,GAAG,IAAI,UAAU,MAAM,EAAE,IAAK;QACvC,MAAM,SAAS,CAAC,EAAE;QAClB,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,KAAK,MAAM,UAAU,MAAM,GAAG,GAAG;YACjD,MAAM,aAAa,OAAO,YAAY,CAAC,KAAK,KAAK,KAAK,CAAC,KAAK,MAAM,KAAK,MAAM,8CAA8C;YAC3H,MAAM;QACV;IACJ;IACA,OAAO;AACX;AAMO,SAAS;IACZ,OAAQ,iEAAiE,IAAI,CAAC,UAAU,SAAS;AACrG;AAyBO,SAAS,oBAAoB,KAAa;IAC7C,2CAA2C;IAC3C,IAAI,SAAS,MAAM,OAAO,CAAC,YAAY;IAEvC,6DAA6D;IAC7D,OAAO,OAAO,MAAM,CAAC,GAAG,WAAW,KAAK,OAAO,KAAK,CAAC,GAAG,WAAW;AACvE"}},
    {"offset": {"line": 279, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 284, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/src/app/api/history/read-all-history/route.ts"],"sourcesContent":["export const dynamic = 'force-dynamic';\r\nimport { jwtTokenVerify } from \"@/app/api/utils/jwt-token-verify\";\r\nimport { execute } from \"@/app/api/utils/mysql\";\r\nimport { nextResponseJson } from \"@/app/api/utils/request-response\";\r\nimport searchParams from \"../../utils/search-params\";\r\nimport { notNull } from \"@/utils/more\";\r\n\r\nexport async function GET(request: any) {\r\n    const tokenData: any = jwtTokenVerify(request);\r\n    if (tokenData === undefined) return nextResponseJson(null, 401);\r\n\r\n    // Get logged user id\r\n    const { dynamicId, email } = tokenData;\r\n    let result = await execute(\"SELECT id FROM users WHERE dynamicId=? AND email=?\", [dynamicId, email])\r\n    if (result.length === 0) return nextResponseJson(null, 401);\r\n    const loggedUserId = result[0].id;\r\n\r\n    const searchKey = searchParams(request, \"searchKey\") || \"\";\r\n    let limit: number | string;\r\n    if (notNull(searchKey)) limit = 50\r\n    else limit = searchParams(request, \"limit\") || 50;\r\n    let mine: string | number | undefined = searchParams(request, \"mine\");\r\n    mine = mine ? parseInt(mine) : 0;\r\n\r\n    // Count total record\r\n    if (mine) result = await execute(`SELECT COUNT(id) as count FROM history WHERE userId=?`, [loggedUserId]);\r\n    else result = await execute(`SELECT COUNT(id) as count FROM history`);\r\n    const totalRecord = result[0].count;\r\n\r\n    if (mine) result = await execute(`\r\n        SELECT * FROM history_view\r\n        WHERE (name LIKE ?\r\n        OR text LIKE ?)\r\n        AND userId=?\r\n        AND isDeleted=0\r\n        ORDER BY id DESC LIMIT ?\r\n        `, [\r\n        `%${searchKey}%`,\r\n        `%${searchKey}%`,\r\n        loggedUserId,\r\n        limit\r\n    ])\r\n    else result = await execute(`\r\n        SELECT * FROM history_view\r\n        WHERE (name LIKE ?\r\n        OR text LIKE ?)\r\n        AND isDeleted=0\r\n        ORDER BY id DESC LIMIT ?\r\n        `, [\r\n        `%${searchKey}%`,\r\n        `%${searchKey}%`,\r\n        limit\r\n    ])\r\n\r\n    if (result.length === 0) return nextResponseJson({\r\n        status: 200,\r\n        data: [],\r\n        haveMoreData: false\r\n    })\r\n\r\n    const haveMoreData = notNull(searchKey) ? false : (totalRecord > limit ? true : false);\r\n    result = result.map((record: any) => ({\r\n        id: record.id,\r\n        user: { id: record.userId, name: record.name, image: record.image },\r\n        text: record.text,\r\n        undoParams: record.undoParams,\r\n        action: record.action,\r\n        createdAt: record.createdAt,\r\n    }))\r\n\r\n    return nextResponseJson({\r\n        status: 200,\r\n        data: result,\r\n        haveMoreData: haveMoreData\r\n    })\r\n};"],"names":[],"mappings":";;;;;;;;;;AAAO,MAAM,UAAU;;;;;;AAOhB,eAAe,IAAI,OAAY;IAClC,MAAM,YAAiB,CAAA,GAAA,sJAAA,CAAA,iBAAc,AAAD,EAAE;IACtC,IAAI,cAAc,WAAW,OAAO,CAAA,GAAA,mJAAA,CAAA,mBAAgB,AAAD,EAAE,MAAM;IAE3D,qBAAqB;IACrB,MAAM,EAAE,SAAS,EAAE,KAAK,EAAE,GAAG;IAC7B,IAAI,SAAS,MAAM,CAAA,GAAA,qIAAA,CAAA,UAAO,AAAD,EAAE,sDAAsD;QAAC;QAAW;KAAM;IACnG,IAAI,OAAO,MAAM,KAAK,GAAG,OAAO,CAAA,GAAA,mJAAA,CAAA,mBAAgB,AAAD,EAAE,MAAM;IACvD,MAAM,eAAe,MAAM,CAAC,EAAE,CAAC,EAAE;IAEjC,MAAM,YAAY,CAAA,GAAA,gJAAA,CAAA,UAAY,AAAD,EAAE,SAAS,gBAAgB;IACxD,IAAI;IACJ,IAAI,CAAA,GAAA,sHAAA,CAAA,UAAO,AAAD,EAAE,YAAY,QAAQ;SAC3B,QAAQ,CAAA,GAAA,gJAAA,CAAA,UAAY,AAAD,EAAE,SAAS,YAAY;IAC/C,IAAI,OAAoC,CAAA,GAAA,gJAAA,CAAA,UAAY,AAAD,EAAE,SAAS;IAC9D,OAAO,OAAO,SAAS,QAAQ;IAE/B,qBAAqB;IACrB,IAAI,MAAM,SAAS,MAAM,CAAA,GAAA,qIAAA,CAAA,UAAO,AAAD,EAAE,CAAC,qDAAqD,CAAC,EAAE;QAAC;KAAa;SACnG,SAAS,MAAM,CAAA,GAAA,qIAAA,CAAA,UAAO,AAAD,EAAE,CAAC,sCAAsC,CAAC;IACpE,MAAM,cAAc,MAAM,CAAC,EAAE,CAAC,KAAK;IAEnC,IAAI,MAAM,SAAS,MAAM,CAAA,GAAA,qIAAA,CAAA,UAAO,AAAD,EAAE,CAAC;;;;;;;QAO9B,CAAC,EAAE;QACH,CAAC,CAAC,EAAE,UAAU,CAAC,CAAC;QAChB,CAAC,CAAC,EAAE,UAAU,CAAC,CAAC;QAChB;QACA;KACH;SACI,SAAS,MAAM,CAAA,GAAA,qIAAA,CAAA,UAAO,AAAD,EAAE,CAAC;;;;;;QAMzB,CAAC,EAAE;QACH,CAAC,CAAC,EAAE,UAAU,CAAC,CAAC;QAChB,CAAC,CAAC,EAAE,UAAU,CAAC,CAAC;QAChB;KACH;IAED,IAAI,OAAO,MAAM,KAAK,GAAG,OAAO,CAAA,GAAA,mJAAA,CAAA,mBAAgB,AAAD,EAAE;QAC7C,QAAQ;QACR,MAAM,EAAE;QACR,cAAc;IAClB;IAEA,MAAM,eAAe,CAAA,GAAA,sHAAA,CAAA,UAAO,AAAD,EAAE,aAAa,QAAS,cAAc,QAAQ,OAAO;IAChF,SAAS,OAAO,GAAG,CAAC,CAAC,SAAgB,CAAC;YAClC,IAAI,OAAO,EAAE;YACb,MAAM;gBAAE,IAAI,OAAO,MAAM;gBAAE,MAAM,OAAO,IAAI;gBAAE,OAAO,OAAO,KAAK;YAAC;YAClE,MAAM,OAAO,IAAI;YACjB,YAAY,OAAO,UAAU;YAC7B,QAAQ,OAAO,MAAM;YACrB,WAAW,OAAO,SAAS;QAC/B,CAAC;IAED,OAAO,CAAA,GAAA,mJAAA,CAAA,mBAAgB,AAAD,EAAE;QACpB,QAAQ;QACR,MAAM;QACN,cAAc;IAClB;AACJ"}},
    {"offset": {"line": 371, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}