{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 5, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/src/app/api/utils/jwt-token-verify.ts"],"sourcesContent":["import { verify } from \"jsonwebtoken\";\r\nexport const jwtTokenVerify = (request: any) => {\r\n    try {\r\n        // if (request.cookies.get(process.env.TOKEN_NAME)) {\r\n        //     const tokenValue = request.cookies.get(process.env.TOKEN_NAME).value;\r\n        // } return undefined;\r\n        const tokenValue = request.headers.get(\"auth-token\")\r\n        let data = verify(tokenValue, process.env.JWT_KEY!);\r\n        return data;\r\n    } catch (error) {\r\n        return undefined;\r\n    }\r\n}"],"names":[],"mappings":";;;;;;AACO,MAAM,iBAAiB,CAAC;IAC3B,IAAI;QACA,qDAAqD;QACrD,4EAA4E;QAC5E,sBAAsB;QACtB,MAAM,aAAa,QAAQ,OAAO,CAAC,GAAG,CAAC;QACvC,IAAI,OAAO,CAAA,GAAA,uIAAA,CAAA,SAAM,AAAD,EAAE,YAAY,QAAQ,GAAG,CAAC,OAAO;QACjD,OAAO;IACX,EAAE,OAAO,OAAO;QACZ,OAAO;IACX;AACJ"}},
    {"offset": {"line": 23, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 28, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/src/app/api/utils/mysql.ts"],"sourcesContent":["import mysql from \"mysql2/promise\";\r\n\r\n/*\r\n- How to create connection using MySQL?\r\nexport async function createConnection(dbName: string) {\r\n    return await mysql.createConnection({\r\n        host: \"localhost\",\r\n        user: \"root\",\r\n        database: dbName,\r\n    });\r\n}\r\n*/\r\n\r\nexport const pool = mysql.createPool({\r\n    host: \"localhost\",\r\n    user: \"root\",\r\n    password: \"\",\r\n    database: \"accounts\",\r\n    waitForConnections: true,\r\n    connectionLimit: 10,\r\n    maxIdle: 10,\r\n    idleTimeout: 60000,\r\n    queueLimit: 0,\r\n    enableKeepAlive: true,\r\n    keepAliveInitialDelay: 0,\r\n})\r\n\r\n\r\nexport async function execute(query: string, params?: any[]) {\r\n    let connection;\r\n    try {\r\n        connection = await pool.getConnection();\r\n        let result: any, tableSchema: any;\r\n        if (params) [result, tableSchema] = await connection.execute(query, params)\r\n        else[result, tableSchema] = await connection.execute(query)\r\n        return result;\r\n    } catch (error) {\r\n        if (connection) connection.release();\r\n        console.log(\"Query:\", query);\r\n        console.error(\"Error:\", error);\r\n    } finally {\r\n        if (connection) connection.release();\r\n    }\r\n}"],"names":[],"mappings":";;;;;;;AAaO,MAAM,OAAO,mIAAA,CAAA,UAAK,CAAC,UAAU,CAAC;IACjC,MAAM;IACN,MAAM;IACN,UAAU;IACV,UAAU;IACV,oBAAoB;IACpB,iBAAiB;IACjB,SAAS;IACT,aAAa;IACb,YAAY;IACZ,iBAAiB;IACjB,uBAAuB;AAC3B;AAGO,eAAe,QAAQ,KAAa,EAAE,MAAc;IACvD,IAAI;IACJ,IAAI;QACA,aAAa,MAAM,KAAK,aAAa;QACrC,IAAI,QAAa;QACjB,IAAI,QAAQ,CAAC,QAAQ,YAAY,GAAG,MAAM,WAAW,OAAO,CAAC,OAAO;aAChE,CAAC,QAAQ,YAAY,GAAG,MAAM,WAAW,OAAO,CAAC;QACrD,OAAO;IACX,EAAE,OAAO,OAAO;QACZ,IAAI,YAAY,WAAW,OAAO;QAClC,QAAQ,GAAG,CAAC,UAAU;QACtB,QAAQ,KAAK,CAAC,UAAU;IAC5B,SAAU;QACN,IAAI,YAAY,WAAW,OAAO;IACtC;AACJ"}},
    {"offset": {"line": 64, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 69, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/src/utils/text-encode-decode.ts"],"sourcesContent":["export function encode(originalData: any) {\r\n    const shuffle: { [key: string]: string } = {\r\n        \"0\": \"1\", \"1\": \"3\", \"2\": \"5\", \"3\": \"7\", \"4\": \"9\",\r\n        \"5\": \"a\", \"6\": \"c\", \"7\": \"f\", \"8\": \"e\", \"9\": \"d\",\r\n        \"a\": \"b\", \"b\": \"8\", \"c\": \"6\", \"d\": \"4\", \"e\": \"2\", \"f\": \"0\"\r\n    };\r\n\r\n    const packet = JSON.stringify([originalData]);\r\n    const encoder = new TextEncoder();\r\n    const byteArray = encoder.encode(packet);\r\n    let hex = Array.from(byteArray).map(byte => byte.toString(16).padStart(2, '0')).join('');\r\n\r\n    let shuffledHex = \"\";\r\n    for (let i = 0; i < hex.length; i++) {\r\n        shuffledHex += shuffle[hex[i]];\r\n    }\r\n    return shuffledHex;\r\n}\r\n\r\nexport function decode(hexadecimalData: any) {\r\n    try {\r\n        const shuffle: { [key: string]: string } = {\r\n            \"1\": \"0\", \"3\": \"1\", \"5\": \"2\", \"7\": \"3\", \"9\": \"4\",\r\n            \"a\": \"5\", \"c\": \"6\", \"f\": \"7\", \"e\": \"8\", \"d\": \"9\",\r\n            \"b\": \"a\", \"8\": \"b\", \"6\": \"c\", \"4\": \"d\", \"2\": \"e\", \"0\": \"f\"\r\n        };\r\n\r\n        let hex = \"\";\r\n        for (let i = 0; i < hexadecimalData.length; i++) {\r\n            hex += shuffle[hexadecimalData[i]];\r\n        }\r\n\r\n        let byteArray = new Uint8Array(hex.match(/.{1,2}/g)!.map(byte => parseInt(byte, 16)));\r\n        const decoder = new TextDecoder();\r\n        const packet = decoder.decode(byteArray);\r\n        const originalData = JSON.parse(packet)[0];\r\n\r\n        return originalData;\r\n    } catch (error) {\r\n        console.log(\"Decode failed\", error);\r\n        return null;\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;AAAO,SAAS,OAAO,YAAiB;IACpC,MAAM,UAAqC;QACvC,KAAK;QAAK,KAAK;QAAK,KAAK;QAAK,KAAK;QAAK,KAAK;QAC7C,KAAK;QAAK,KAAK;QAAK,KAAK;QAAK,KAAK;QAAK,KAAK;QAC7C,KAAK;QAAK,KAAK;QAAK,KAAK;QAAK,KAAK;QAAK,KAAK;QAAK,KAAK;IAC3D;IAEA,MAAM,SAAS,KAAK,SAAS,CAAC;QAAC;KAAa;IAC5C,MAAM,UAAU,IAAI;IACpB,MAAM,YAAY,QAAQ,MAAM,CAAC;IACjC,IAAI,MAAM,MAAM,IAAI,CAAC,WAAW,GAAG,CAAC,CAAA,OAAQ,KAAK,QAAQ,CAAC,IAAI,QAAQ,CAAC,GAAG,MAAM,IAAI,CAAC;IAErF,IAAI,cAAc;IAClB,IAAK,IAAI,IAAI,GAAG,IAAI,IAAI,MAAM,EAAE,IAAK;QACjC,eAAe,OAAO,CAAC,GAAG,CAAC,EAAE,CAAC;IAClC;IACA,OAAO;AACX;AAEO,SAAS,OAAO,eAAoB;IACvC,IAAI;QACA,MAAM,UAAqC;YACvC,KAAK;YAAK,KAAK;YAAK,KAAK;YAAK,KAAK;YAAK,KAAK;YAC7C,KAAK;YAAK,KAAK;YAAK,KAAK;YAAK,KAAK;YAAK,KAAK;YAC7C,KAAK;YAAK,KAAK;YAAK,KAAK;YAAK,KAAK;YAAK,KAAK;YAAK,KAAK;QAC3D;QAEA,IAAI,MAAM;QACV,IAAK,IAAI,IAAI,GAAG,IAAI,gBAAgB,MAAM,EAAE,IAAK;YAC7C,OAAO,OAAO,CAAC,eAAe,CAAC,EAAE,CAAC;QACtC;QAEA,IAAI,YAAY,IAAI,WAAW,IAAI,KAAK,CAAC,WAAY,GAAG,CAAC,CAAA,OAAQ,SAAS,MAAM;QAChF,MAAM,UAAU,IAAI;QACpB,MAAM,SAAS,QAAQ,MAAM,CAAC;QAC9B,MAAM,eAAe,KAAK,KAAK,CAAC,OAAO,CAAC,EAAE;QAE1C,OAAO;IACX,EAAE,OAAO,OAAO;QACZ,QAAQ,GAAG,CAAC,iBAAiB;QAC7B,OAAO;IACX;AACJ"}},
    {"offset": {"line": 138, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 143, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/src/app/api/utils/request-response.ts"],"sourcesContent":["import { decode, encode } from \"@/utils/text-encode-decode\";\r\nimport { NextResponse } from \"next/server\";\r\n\r\n/*****\r\n * Modified version of receive requested payload\r\n * Prevent showing actual response on client browser\r\n * Able to received text, object, array, number, boolean etc. in encoded format\r\n ******/\r\nexport async function requestJson(request: any) {\r\n    const data = await request.json();\r\n    return decode(data.payload)\r\n}\r\n/*****\r\n * Modified version of NextResponse.json()\r\n * Prevent showing actual response on client browser\r\n * Able to return text, object, array, number, boolean etc. in encoded format\r\n ******/\r\nconst doEncode = true;\r\nexport function nextResponseJson(data: any, status?: number) {\r\n    if (doEncode) return NextResponse.json(data ? encode(data) : null, { status: status ? status : 200 })\r\n    else return NextResponse.json(data ? data : null, { status: status ? status : 200 })\r\n}"],"names":[],"mappings":";;;;;;;;;AAQO,eAAe,YAAY,OAAY;IAC1C,MAAM,OAAO,MAAM,QAAQ,IAAI;IAC/B,OAAO,CAAA,GAAA,0IAAA,CAAA,SAAM,AAAD,EAAE,KAAK,OAAO;AAC9B;AACA;;;;MAIM,GACN,MAAM,WAAW;AACV,SAAS,iBAAiB,IAAS,EAAE,MAAe;IACvD,wCAAc,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC,OAAO,CAAA,GAAA,0IAAA,CAAA,SAAM,AAAD,EAAE,QAAQ,MAAM;QAAE,QAAQ,SAAS,SAAS;IAAI;;;;AAEvG"}},
    {"offset": {"line": 169, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 174, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/src/app/api/users/delete-user/[id]/route.ts"],"sourcesContent":["import { jwtTokenVerify } from \"@/app/api/utils/jwt-token-verify\";\r\nimport { execute } from \"@/app/api/utils/mysql\";\r\nimport { nextResponseJson } from \"@/app/api/utils/request-response\";\r\nimport { encode } from \"@/utils/text-encode-decode\";\r\n\r\nexport async function DELETE(request: any, { params }: { params: { id: string } }) {\r\n    const tokenData: any = jwtTokenVerify(request);\r\n    if (tokenData === undefined) return nextResponseJson(null, 401);\r\n\r\n    // Get logged user id\r\n    const { dynamicId, email } = tokenData;\r\n    let result = await execute(\"SELECT id FROM users WHERE dynamicId=? AND email=?\", [dynamicId, email])\r\n    if (result.length === 0) return nextResponseJson(null, 401);\r\n    const loggedUserId = result[0].id;\r\n    const id = parseInt(params.id);\r\n\r\n    // Hide the user\r\n    await execute(\"UPDATE users SET isDeleted=1, updatedAt=CURRENT_TIMESTAMP, updatedBy=? WHERE id=?\", [loggedUserId, id])\r\n\r\n    // If the user is student then decrease session count\r\n    result = await execute(\"SELECT sessionId FROM users WHERE id=? and role=?\", [id, \"student\"])\r\n    if (result.length > 0) {\r\n        const sessionId = result[0].sessionId;\r\n        await execute(\"UPDATE session SET usedByUser=usedByUser-1, updatedAt=CURRENT_TIMESTAMP, updatedBy=? WHERE id=?\", [loggedUserId, sessionId])\r\n    }\r\n\r\n    // Add history\r\n    await (async () => {\r\n        const result = await execute(\"SELECT name, email, role FROM users WHERE id=?\", [id])\r\n        const name = result[0].name;\r\n        const email = result[0].email;\r\n        const text = `${name}(${email}) is deleted`\r\n        await execute(\"INSERT INTO history(userId, text, action, undoParams) VALUES (?,?,?,?)\", [loggedUserId, text, \"Delete\", encode({\r\n            database: \"accounts\",\r\n            case: \"delete user\",\r\n            userId: id\r\n        })])\r\n    })()\r\n\r\n    return nextResponseJson({ status: 200 });\r\n};"],"names":[],"mappings":";;;;;;;;;;;;AAKO,eAAe,OAAO,OAAY,EAAE,EAAE,MAAM,EAA8B;IAC7E,MAAM,YAAiB,CAAA,GAAA,sJAAA,CAAA,iBAAc,AAAD,EAAE;IACtC,IAAI,cAAc,WAAW,OAAO,CAAA,GAAA,mJAAA,CAAA,mBAAgB,AAAD,EAAE,MAAM;IAE3D,qBAAqB;IACrB,MAAM,EAAE,SAAS,EAAE,KAAK,EAAE,GAAG;IAC7B,IAAI,SAAS,MAAM,CAAA,GAAA,qIAAA,CAAA,UAAO,AAAD,EAAE,sDAAsD;QAAC;QAAW;KAAM;IACnG,IAAI,OAAO,MAAM,KAAK,GAAG,OAAO,CAAA,GAAA,mJAAA,CAAA,mBAAgB,AAAD,EAAE,MAAM;IACvD,MAAM,eAAe,MAAM,CAAC,EAAE,CAAC,EAAE;IACjC,MAAM,KAAK,SAAS,OAAO,EAAE;IAE7B,gBAAgB;IAChB,MAAM,CAAA,GAAA,qIAAA,CAAA,UAAO,AAAD,EAAE,qFAAqF;QAAC;QAAc;KAAG;IAErH,qDAAqD;IACrD,SAAS,MAAM,CAAA,GAAA,qIAAA,CAAA,UAAO,AAAD,EAAE,qDAAqD;QAAC;QAAI;KAAU;IAC3F,IAAI,OAAO,MAAM,GAAG,GAAG;QACnB,MAAM,YAAY,MAAM,CAAC,EAAE,CAAC,SAAS;QACrC,MAAM,CAAA,GAAA,qIAAA,CAAA,UAAO,AAAD,EAAE,mGAAmG;YAAC;YAAc;SAAU;IAC9I;IAEA,cAAc;IACd,MAAM,CAAC;QACH,MAAM,SAAS,MAAM,CAAA,GAAA,qIAAA,CAAA,UAAO,AAAD,EAAE,kDAAkD;YAAC;SAAG;QACnF,MAAM,OAAO,MAAM,CAAC,EAAE,CAAC,IAAI;QAC3B,MAAM,QAAQ,MAAM,CAAC,EAAE,CAAC,KAAK;QAC7B,MAAM,OAAO,CAAC,EAAE,KAAK,CAAC,EAAE,MAAM,YAAY,CAAC;QAC3C,MAAM,CAAA,GAAA,qIAAA,CAAA,UAAO,AAAD,EAAE,0EAA0E;YAAC;YAAc;YAAM;YAAU,CAAA,GAAA,0IAAA,CAAA,SAAM,AAAD,EAAE;gBAC1H,UAAU;gBACV,MAAM;gBACN,QAAQ;YACZ;SAAG;IACP,CAAC;IAED,OAAO,CAAA,GAAA,mJAAA,CAAA,mBAAgB,AAAD,EAAE;QAAE,QAAQ;IAAI;AAC1C"}},
    {"offset": {"line": 238, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}